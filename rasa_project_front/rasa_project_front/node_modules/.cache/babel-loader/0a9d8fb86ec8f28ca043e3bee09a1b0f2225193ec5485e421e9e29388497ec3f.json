{"ast":null,"code":"import { cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical } from \"../cartesian.js\";\nimport { circleStream } from \"../circle.js\";\nimport { abs, cos, epsilon, pi, radians, sqrt } from \"../math.js\";\nimport pointEqual from \"../pointEqual.js\";\nimport clip from \"./index.js\";\nexport default function (radius) {\n  var cr = cos(radius),\n    delta = 6 * radians,\n    smallRadius = cr > 0,\n    notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0,\n      // previous point\n      c0,\n      // code for previous point\n      v0,\n      // visibility of previous point\n      v00,\n      // visibility of first point\n      clean; // no intersections\n    return {\n      lineStart: function () {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function (lambda, phi) {\n        var point1 = [lambda, phi],\n          point2,\n          v = visible(lambda, phi),\n          c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) point1[2] = 1;\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1], 2);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function () {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function () {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n      pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n    var n1 = [1, 0, 0],\n      // normal\n      n2 = cartesianCross(pa, pb),\n      n2n2 = cartesianDot(n2, n2),\n      n1n2 = n2[0],\n      // cartesianDot(n1, n2),\n      determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n    var c1 = cr * n2n2 / determinant,\n      c2 = -cr * n1n2 / determinant,\n      n1xn2 = cartesianCross(n1, n2),\n      A = cartesianScale(n1, c1),\n      B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n      w = cartesianDot(A, u),\n      uu = cartesianDot(u, u),\n      t2 = w * w - uu * (cartesianDot(A, A) - 1);\n    if (t2 < 0) return;\n    var t = sqrt(t2),\n      q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n      lambda1 = b[0],\n      phi0 = a[1],\n      phi1 = b[1],\n      z;\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n    var delta = lambda1 - lambda0,\n      polar = abs(delta - pi) < epsilon,\n      meridian = polar || delta < epsilon;\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n      code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}","map":{"version":3,"names":["cartesian","cartesianAddInPlace","cartesianCross","cartesianDot","cartesianScale","spherical","circleStream","abs","cos","epsilon","pi","radians","sqrt","pointEqual","clip","radius","cr","delta","smallRadius","notHemisphere","interpolate","from","to","direction","stream","visible","lambda","phi","clipLine","point0","c0","v0","v00","clean","lineStart","point","point1","point2","v","c","code","intersect","lineEnd","t","a","b","two","pa","pb","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","B","u","w","uu","t2","q","lambda0","lambda1","phi0","phi1","z","polar","meridian","q1","r"],"sources":["D:/python/rasa_project_for_windows/rasa_project_front/node_modules/d3-geo/src/clip/circle.js"],"sourcesContent":["import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian.js\";\nimport {circleStream} from \"../circle.js\";\nimport {abs, cos, epsilon, pi, radians, sqrt} from \"../math.js\";\nimport pointEqual from \"../pointEqual.js\";\nimport clip from \"./index.js\";\n\nexport default function(radius) {\n  var cr = cos(radius),\n      delta = 6 * radians,\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))\n            point1[2] = 1;\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1], 2);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}