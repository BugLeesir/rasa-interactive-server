{"ast":null,"code":"import { Adder } from \"d3-array\";\nimport { asin, atan2, cos, degrees, epsilon, epsilon2, hypot, radians, sin, sqrt } from \"./math.js\";\nimport noop from \"./noop.js\";\nimport stream from \"./stream.js\";\nvar W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00,\n  // first point\n  x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function () {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function () {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n    x = cosPhi * cos(lambda),\n    y = cosPhi * sin(lambda),\n    z = sin(phi),\n    w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n    x = cosPhi * cos(lambda),\n    y = cosPhi * sin(lambda),\n    z = sin(phi),\n    cx = y0 * z - z0 * y,\n    cy = z0 * x - x0 * z,\n    cz = x0 * y - y0 * x,\n    m = hypot(cx, cy, cz),\n    w = asin(m),\n    // line weight = angle\n    v = m && -w / m; // area weight multiplier\n  X2.add(v * cx);\n  Y2.add(v * cy);\n  Z2.add(v * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nexport default function (object) {\n  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream(object, centroidStream);\n  var x = +X2,\n    y = +Y2,\n    z = +Z2,\n    m = hypot(x, y, z);\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = hypot(x, y, z);\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n  return [atan2(y, x) * degrees, asin(z / m) * degrees];\n}","map":{"version":3,"names":["Adder","asin","atan2","cos","degrees","epsilon","epsilon2","hypot","radians","sin","sqrt","noop","stream","W0","W1","X0","Y0","Z0","X1","Y1","Z1","X2","Y2","Z2","lambda00","phi00","x0","y0","z0","centroidStream","sphere","point","centroidPoint","lineStart","centroidLineStart","lineEnd","centroidLineEnd","polygonStart","centroidRingStart","centroidRingEnd","polygonEnd","lambda","phi","cosPhi","centroidPointCartesian","x","y","z","centroidLinePointFirst","centroidLinePoint","w","centroidRingPointFirst","centroidRingPoint","cx","cy","cz","m","v","add","object","NaN"],"sources":["D:/python/rasa_project_for_windows/rasa_project_front/node_modules/d3-geo/src/centroid.js"],"sourcesContent":["import {Adder} from \"d3-array\";\nimport {asin, atan2, cos, degrees, epsilon, epsilon2, hypot, radians, sin, sqrt} from \"./math.js\";\nimport noop from \"./noop.js\";\nimport stream from \"./stream.js\";\n\nvar W0, W1,\n    X0, Y0, Z0,\n    X1, Y1, Z1,\n    X2, Y2, Z2,\n    lambda00, phi00, // first point\n    x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = hypot(cx, cy, cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2.add(v * cx);\n  Y2.add(v * cy);\n  Z2.add(v * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream(object, centroidStream);\n\n  var x = +X2,\n      y = +Y2,\n      z = +Z2,\n      m = hypot(x, y, z);\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = hypot(x, y, z);\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / m) * degrees];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}