{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { abs, epsilon } from \"../math.js\";\nimport clipBuffer from \"./buffer.js\";\nimport clipLine from \"./line.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport { merge } from \"d3-array\";\nvar clipMax = 1e9,\n  clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n  function interpolate(from, to, direction, stream) {\n    var a = 0,\n      a1 = 0;\n    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n      cb = corner(b, 1);\n    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n  }\n  return function (stream) {\n    var activeStream = stream,\n      bufferStream = clipBuffer(),\n      segments,\n      polygon,\n      ring,\n      x__,\n      y__,\n      v__,\n      // first point\n      x_,\n      y_,\n      v_,\n      // previous point\n      first,\n      clean;\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n    function polygonInside() {\n      var winding = 0;\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) {\n            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;\n          } else {\n            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;\n          }\n        }\n      }\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n    function polygonEnd() {\n      var startInside = polygonInside(),\n        cleanInside = clean && startInside,\n        visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n            b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n    return clipStream;\n  };\n}","map":{"version":3,"names":["abs","epsilon","clipBuffer","clipLine","clipRejoin","merge","clipMax","clipMin","clipRectangle","x0","y0","x1","y1","visible","x","y","interpolate","from","to","direction","stream","a","a1","corner","comparePoint","point","p","compareIntersection","b","ca","cb","activeStream","bufferStream","segments","polygon","ring","x__","y__","v__","x_","y_","v_","first","clean","clipStream","lineStart","lineEnd","polygonStart","polygonEnd","polygonInside","winding","i","n","length","j","m","a0","b0","b1","startInside","cleanInside","linePoint","push","NaN","rejoin","result","v","Math","max","min"],"sources":["D:/python/rasa_project_for_windows/rasa_project_front/node_modules/d3-geo/src/clip/rectangle.js"],"sourcesContent":["import {abs, epsilon} from \"../math.js\";\nimport clipBuffer from \"./buffer.js\";\nimport clipLine from \"./line.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}