{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { extent, nice, thresholdSturges, ticks } from \"d3-array\";\nimport { slice } from \"./array.js\";\nimport ascending from \"./ascending.js\";\nimport area from \"./area.js\";\nimport constant from \"./constant.js\";\nimport contains from \"./contains.js\";\nimport noop from \"./noop.js\";\nvar cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []];\nexport default function () {\n  var dx = 1,\n    dy = 1,\n    threshold = thresholdSturges,\n    smooth = smoothLinear;\n  function contours(values) {\n    var tz = threshold(values);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      const e = extent(values, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1]) tz.pop();\n      while (tz[1] < e[0]) tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n    return tz.map(value => contour(values, value));\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    const v = value == null ? NaN : +value;\n    if (isNaN(v)) throw new Error(`invalid value: ${value}`);\n    var polygons = [],\n      holes = [];\n    isorings(values, v, function (ring) {\n      smooth(ring, values, v);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(function (hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array(),\n      fragmentByEnd = new Array(),\n      x,\n      y,\n      t0,\n      t1,\n      t2,\n      t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = above(values[0], value);\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = above(values[x + 1], value);\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = above(values[y * dx + dx], value);\n      t2 = above(values[y * dx], value);\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);\n        t3 = t2, t2 = above(values[y * dx + x + 1], value);\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = above(values[y * dx + x + 1], value);\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n        end = [line[1][0] + x, line[1][1] + y],\n        startIndex = index(start),\n        endIndex = index(end),\n        f,\n        g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function (point) {\n      var x = point[0],\n        y = point[1],\n        xt = x | 0,\n        yt = y | 0,\n        v1 = valid(values[yt * dx + xt]);\n      if (x > 0 && x < dx && xt === x) {\n        point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);\n      }\n      if (y > 0 && y < dy && yt === y) {\n        point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n  contours.contour = contour;\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]),\n      _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n  contours.thresholds = function (_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\n\n// When computing the extent, ignore infinite values (as well as invalid ones).\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n\n// Is the (possibly invalid) x greater than or equal to the (known valid) value?\n// Treat any invalid value as below negative infinity.\nfunction above(x, value) {\n  return x == null ? false : +x >= value;\n}\n\n// During smoothing, treat any invalid value as negative infinity.\nfunction valid(v) {\n  return v == null || isNaN(v = +v) ? -Infinity : v;\n}\nfunction smooth1(x, v0, v1, value) {\n  const a = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);\n  return isNaN(d) ? x : x + d - 0.5;\n}","map":{"version":3,"names":["extent","nice","thresholdSturges","ticks","slice","ascending","area","constant","contains","noop","cases","dx","dy","threshold","smooth","smoothLinear","contours","values","tz","Array","isArray","e","finite","length","pop","shift","sort","map","value","contour","v","NaN","isNaN","Error","polygons","holes","isorings","ring","push","forEach","hole","i","n","polygon","type","coordinates","callback","fragmentByStart","fragmentByEnd","x","y","t0","t1","t2","t3","above","stitch","line","start","end","startIndex","index","endIndex","f","g","concat","unshift","point","xt","yt","v1","valid","smooth1","size","_","arguments","_0","Math","floor","_1","thresholds","call","isFinite","Infinity","v0","a","b","d","sign"],"sources":["E:/MyCodes/Rasa/rasa_project_for_windows/rasa_project_front/rasa_project_front/node_modules/d3-contour/src/contours.js"],"sourcesContent":["import {extent, nice, thresholdSturges, ticks} from \"d3-array\";\nimport {slice} from \"./array.js\";\nimport ascending from \"./ascending.js\";\nimport area from \"./area.js\";\nimport constant from \"./constant.js\";\nimport contains from \"./contains.js\";\nimport noop from \"./noop.js\";\n\nvar cases = [\n  [],\n  [[[1.0, 1.5], [0.5, 1.0]]],\n  [[[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [0.5, 1.0]]],\n  [[[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 0.5], [1.0, 1.5]]],\n  [[[1.0, 0.5], [0.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 0.5]]],\n  [[[1.0, 1.5], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.5, 1.0]]],\n  [[[1.0, 1.5], [1.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 1.5]]],\n  []\n];\n\nexport default function() {\n  var dx = 1,\n      dy = 1,\n      threshold = thresholdSturges,\n      smooth = smoothLinear;\n\n  function contours(values) {\n    var tz = threshold(values);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      const e = extent(values, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1]) tz.pop();\n      while (tz[1] < e[0]) tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n\n    return tz.map(value => contour(values, value));\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    const v = value == null ? NaN : +value;\n    if (isNaN(v)) throw new Error(`invalid value: ${value}`);\n\n    var polygons = [],\n        holes = [];\n\n    isorings(values, v, function(ring) {\n      smooth(ring, values, v);\n      if (area(ring) > 0) polygons.push([ring]);\n      else holes.push(ring);\n    });\n\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array,\n        fragmentByEnd = new Array,\n        x, y, t0, t1, t2, t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = above(values[0], value);\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = above(values[x + 1], value);\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = above(values[y * dx + dx], value);\n      t2 = above(values[y * dx], value);\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);\n        t3 = t2, t2 = above(values[y * dx + x + 1], value);\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = above(values[y * dx + x + 1], value);\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function(point) {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v1 = valid(values[yt * dx + xt]);\n      if (x > 0 && x < dx && xt === x) {\n        point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);\n      }\n      if (y > 0 && y < dy && yt === y) {\n        point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n\n// When computing the extent, ignore infinite values (as well as invalid ones).\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n\n// Is the (possibly invalid) x greater than or equal to the (known valid) value?\n// Treat any invalid value as below negative infinity.\nfunction above(x, value) {\n  return x == null ? false : +x >= value;\n}\n\n// During smoothing, treat any invalid value as negative infinity.\nfunction valid(v) {\n  return v == null || isNaN(v = +v) ? -Infinity : v;\n}\n\nfunction smooth1(x, v0, v1, value) {\n  const a = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);\n  return isNaN(d) ? x : x + d - 0.5;\n}\n"],"mappings":";AAAA,SAAQA,MAAM,EAAEC,IAAI,EAAEC,gBAAgB,EAAEC,KAAK,QAAO,UAAU;AAC9D,SAAQC,KAAK,QAAO,YAAY;AAChC,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,IAAI,MAAM,WAAW;AAC5B,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,IAAI,MAAM,WAAW;AAE5B,IAAIC,KAAK,GAAG,CACV,EAAE,EACF,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EACpD,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EACpD,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,EAC1B,EAAE,CACH;AAED,eAAe,YAAW;EACxB,IAAIC,EAAE,GAAG,CAAC;IACNC,EAAE,GAAG,CAAC;IACNC,SAAS,GAAGX,gBAAgB;IAC5BY,MAAM,GAAGC,YAAY;EAEzB,SAASC,QAAQA,CAACC,MAAM,EAAE;IACxB,IAAIC,EAAE,GAAGL,SAAS,CAACI,MAAM,CAAC;;IAE1B;IACA,IAAI,CAACE,KAAK,CAACC,OAAO,CAACF,EAAE,CAAC,EAAE;MACtB,MAAMG,CAAC,GAAGrB,MAAM,CAACiB,MAAM,EAAEK,MAAM,CAAC;MAChCJ,EAAE,GAAGf,KAAK,CAAC,GAAGF,IAAI,CAACoB,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEH,EAAE,CAAC,EAAEA,EAAE,CAAC;MACvC,OAAOA,EAAE,CAACA,EAAE,CAACK,MAAM,GAAG,CAAC,CAAC,IAAIF,CAAC,CAAC,CAAC,CAAC,EAAEH,EAAE,CAACM,GAAG,CAAC,CAAC;MAC1C,OAAON,EAAE,CAAC,CAAC,CAAC,GAAGG,CAAC,CAAC,CAAC,CAAC,EAAEH,EAAE,CAACO,KAAK,CAAC,CAAC;IACjC,CAAC,MAAM;MACLP,EAAE,GAAGA,EAAE,CAACd,KAAK,CAAC,CAAC,CAACsB,IAAI,CAACrB,SAAS,CAAC;IACjC;IAEA,OAAOa,EAAE,CAACS,GAAG,CAACC,KAAK,IAAIC,OAAO,CAACZ,MAAM,EAAEW,KAAK,CAAC,CAAC;EAChD;;EAEA;EACA;EACA,SAASC,OAAOA,CAACZ,MAAM,EAAEW,KAAK,EAAE;IAC9B,MAAME,CAAC,GAAGF,KAAK,IAAI,IAAI,GAAGG,GAAG,GAAG,CAACH,KAAK;IACtC,IAAII,KAAK,CAACF,CAAC,CAAC,EAAE,MAAM,IAAIG,KAAK,CAAE,kBAAiBL,KAAM,EAAC,CAAC;IAExD,IAAIM,QAAQ,GAAG,EAAE;MACbC,KAAK,GAAG,EAAE;IAEdC,QAAQ,CAACnB,MAAM,EAAEa,CAAC,EAAE,UAASO,IAAI,EAAE;MACjCvB,MAAM,CAACuB,IAAI,EAAEpB,MAAM,EAAEa,CAAC,CAAC;MACvB,IAAIxB,IAAI,CAAC+B,IAAI,CAAC,GAAG,CAAC,EAAEH,QAAQ,CAACI,IAAI,CAAC,CAACD,IAAI,CAAC,CAAC,CAAC,KACrCF,KAAK,CAACG,IAAI,CAACD,IAAI,CAAC;IACvB,CAAC,CAAC;IAEFF,KAAK,CAACI,OAAO,CAAC,UAASC,IAAI,EAAE;MAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGR,QAAQ,CAACX,MAAM,EAAEoB,OAAO,EAAEF,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;QACxD,IAAIjC,QAAQ,CAAC,CAACmC,OAAO,GAAGT,QAAQ,CAACO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAED,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;UACrDG,OAAO,CAACL,IAAI,CAACE,IAAI,CAAC;UAClB;QACF;MACF;IACF,CAAC,CAAC;IAEF,OAAO;MACLI,IAAI,EAAE,cAAc;MACpBhB,KAAK,EAAEA,KAAK;MACZiB,WAAW,EAAEX;IACf,CAAC;EACH;;EAEA;EACA;EACA,SAASE,QAAQA,CAACnB,MAAM,EAAEW,KAAK,EAAEkB,QAAQ,EAAE;IACzC,IAAIC,eAAe,GAAG,IAAI5B,KAAK,CAAD,CAAC;MAC3B6B,aAAa,GAAG,IAAI7B,KAAK,CAAD,CAAC;MACzB8B,CAAC;MAAEC,CAAC;MAAEC,EAAE;MAAEC,EAAE;MAAEC,EAAE;MAAEC,EAAE;;IAExB;IACAL,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC;IACVE,EAAE,GAAGG,KAAK,CAACtC,MAAM,CAAC,CAAC,CAAC,EAAEW,KAAK,CAAC;IAC5BlB,KAAK,CAAC0C,EAAE,IAAI,CAAC,CAAC,CAACb,OAAO,CAACiB,MAAM,CAAC;IAC9B,OAAO,EAAEP,CAAC,GAAGtC,EAAE,GAAG,CAAC,EAAE;MACnBwC,EAAE,GAAGC,EAAE,EAAEA,EAAE,GAAGG,KAAK,CAACtC,MAAM,CAACgC,CAAC,GAAG,CAAC,CAAC,EAAErB,KAAK,CAAC;MACzClB,KAAK,CAACyC,EAAE,GAAGC,EAAE,IAAI,CAAC,CAAC,CAACb,OAAO,CAACiB,MAAM,CAAC;IACrC;IACA9C,KAAK,CAAC0C,EAAE,IAAI,CAAC,CAAC,CAACb,OAAO,CAACiB,MAAM,CAAC;;IAE9B;IACA,OAAO,EAAEN,CAAC,GAAGtC,EAAE,GAAG,CAAC,EAAE;MACnBqC,CAAC,GAAG,CAAC,CAAC;MACNG,EAAE,GAAGG,KAAK,CAACtC,MAAM,CAACiC,CAAC,GAAGvC,EAAE,GAAGA,EAAE,CAAC,EAAEiB,KAAK,CAAC;MACtCyB,EAAE,GAAGE,KAAK,CAACtC,MAAM,CAACiC,CAAC,GAAGvC,EAAE,CAAC,EAAEiB,KAAK,CAAC;MACjClB,KAAK,CAAC0C,EAAE,IAAI,CAAC,GAAGC,EAAE,IAAI,CAAC,CAAC,CAACd,OAAO,CAACiB,MAAM,CAAC;MACxC,OAAO,EAAEP,CAAC,GAAGtC,EAAE,GAAG,CAAC,EAAE;QACnBwC,EAAE,GAAGC,EAAE,EAAEA,EAAE,GAAGG,KAAK,CAACtC,MAAM,CAACiC,CAAC,GAAGvC,EAAE,GAAGA,EAAE,GAAGsC,CAAC,GAAG,CAAC,CAAC,EAAErB,KAAK,CAAC;QACvD0B,EAAE,GAAGD,EAAE,EAAEA,EAAE,GAAGE,KAAK,CAACtC,MAAM,CAACiC,CAAC,GAAGvC,EAAE,GAAGsC,CAAC,GAAG,CAAC,CAAC,EAAErB,KAAK,CAAC;QAClDlB,KAAK,CAACyC,EAAE,GAAGC,EAAE,IAAI,CAAC,GAAGC,EAAE,IAAI,CAAC,GAAGC,EAAE,IAAI,CAAC,CAAC,CAACf,OAAO,CAACiB,MAAM,CAAC;MACzD;MACA9C,KAAK,CAAC0C,EAAE,GAAGC,EAAE,IAAI,CAAC,CAAC,CAACd,OAAO,CAACiB,MAAM,CAAC;IACrC;;IAEA;IACAP,CAAC,GAAG,CAAC,CAAC;IACNI,EAAE,GAAGpC,MAAM,CAACiC,CAAC,GAAGvC,EAAE,CAAC,IAAIiB,KAAK;IAC5BlB,KAAK,CAAC2C,EAAE,IAAI,CAAC,CAAC,CAACd,OAAO,CAACiB,MAAM,CAAC;IAC9B,OAAO,EAAEP,CAAC,GAAGtC,EAAE,GAAG,CAAC,EAAE;MACnB2C,EAAE,GAAGD,EAAE,EAAEA,EAAE,GAAGE,KAAK,CAACtC,MAAM,CAACiC,CAAC,GAAGvC,EAAE,GAAGsC,CAAC,GAAG,CAAC,CAAC,EAAErB,KAAK,CAAC;MAClDlB,KAAK,CAAC2C,EAAE,IAAI,CAAC,GAAGC,EAAE,IAAI,CAAC,CAAC,CAACf,OAAO,CAACiB,MAAM,CAAC;IAC1C;IACA9C,KAAK,CAAC2C,EAAE,IAAI,CAAC,CAAC,CAACd,OAAO,CAACiB,MAAM,CAAC;IAE9B,SAASA,MAAMA,CAACC,IAAI,EAAE;MACpB,IAAIC,KAAK,GAAG,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGR,CAAC,EAAEQ,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGP,CAAC,CAAC;QACxCS,GAAG,GAAG,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGR,CAAC,EAAEQ,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGP,CAAC,CAAC;QACtCU,UAAU,GAAGC,KAAK,CAACH,KAAK,CAAC;QACzBI,QAAQ,GAAGD,KAAK,CAACF,GAAG,CAAC;QACrBI,CAAC;QAAEC,CAAC;MACR,IAAID,CAAC,GAAGf,aAAa,CAACY,UAAU,CAAC,EAAE;QACjC,IAAII,CAAC,GAAGjB,eAAe,CAACe,QAAQ,CAAC,EAAE;UACjC,OAAOd,aAAa,CAACe,CAAC,CAACJ,GAAG,CAAC;UAC3B,OAAOZ,eAAe,CAACiB,CAAC,CAACN,KAAK,CAAC;UAC/B,IAAIK,CAAC,KAAKC,CAAC,EAAE;YACXD,CAAC,CAAC1B,IAAI,CAACC,IAAI,CAACqB,GAAG,CAAC;YAChBb,QAAQ,CAACiB,CAAC,CAAC1B,IAAI,CAAC;UAClB,CAAC,MAAM;YACLU,eAAe,CAACgB,CAAC,CAACL,KAAK,CAAC,GAAGV,aAAa,CAACgB,CAAC,CAACL,GAAG,CAAC,GAAG;cAACD,KAAK,EAAEK,CAAC,CAACL,KAAK;cAAEC,GAAG,EAAEK,CAAC,CAACL,GAAG;cAAEtB,IAAI,EAAE0B,CAAC,CAAC1B,IAAI,CAAC4B,MAAM,CAACD,CAAC,CAAC3B,IAAI;YAAC,CAAC;UAC7G;QACF,CAAC,MAAM;UACL,OAAOW,aAAa,CAACe,CAAC,CAACJ,GAAG,CAAC;UAC3BI,CAAC,CAAC1B,IAAI,CAACC,IAAI,CAACqB,GAAG,CAAC;UAChBX,aAAa,CAACe,CAAC,CAACJ,GAAG,GAAGG,QAAQ,CAAC,GAAGC,CAAC;QACrC;MACF,CAAC,MAAM,IAAIA,CAAC,GAAGhB,eAAe,CAACe,QAAQ,CAAC,EAAE;QACxC,IAAIE,CAAC,GAAGhB,aAAa,CAACY,UAAU,CAAC,EAAE;UACjC,OAAOb,eAAe,CAACgB,CAAC,CAACL,KAAK,CAAC;UAC/B,OAAOV,aAAa,CAACgB,CAAC,CAACL,GAAG,CAAC;UAC3B,IAAII,CAAC,KAAKC,CAAC,EAAE;YACXD,CAAC,CAAC1B,IAAI,CAACC,IAAI,CAACqB,GAAG,CAAC;YAChBb,QAAQ,CAACiB,CAAC,CAAC1B,IAAI,CAAC;UAClB,CAAC,MAAM;YACLU,eAAe,CAACiB,CAAC,CAACN,KAAK,CAAC,GAAGV,aAAa,CAACe,CAAC,CAACJ,GAAG,CAAC,GAAG;cAACD,KAAK,EAAEM,CAAC,CAACN,KAAK;cAAEC,GAAG,EAAEI,CAAC,CAACJ,GAAG;cAAEtB,IAAI,EAAE2B,CAAC,CAAC3B,IAAI,CAAC4B,MAAM,CAACF,CAAC,CAAC1B,IAAI;YAAC,CAAC;UAC7G;QACF,CAAC,MAAM;UACL,OAAOU,eAAe,CAACgB,CAAC,CAACL,KAAK,CAAC;UAC/BK,CAAC,CAAC1B,IAAI,CAAC6B,OAAO,CAACR,KAAK,CAAC;UACrBX,eAAe,CAACgB,CAAC,CAACL,KAAK,GAAGE,UAAU,CAAC,GAAGG,CAAC;QAC3C;MACF,CAAC,MAAM;QACLhB,eAAe,CAACa,UAAU,CAAC,GAAGZ,aAAa,CAACc,QAAQ,CAAC,GAAG;UAACJ,KAAK,EAAEE,UAAU;UAAED,GAAG,EAAEG,QAAQ;UAAEzB,IAAI,EAAE,CAACqB,KAAK,EAAEC,GAAG;QAAC,CAAC;MAChH;IACF;EACF;EAEA,SAASE,KAAKA,CAACM,KAAK,EAAE;IACpB,OAAOA,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,IAAIxD,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC;EAC/C;EAEA,SAASI,YAAYA,CAACsB,IAAI,EAAEpB,MAAM,EAAEW,KAAK,EAAE;IACzCS,IAAI,CAACE,OAAO,CAAC,UAAS4B,KAAK,EAAE;MAC3B,IAAIlB,CAAC,GAAGkB,KAAK,CAAC,CAAC,CAAC;QACZjB,CAAC,GAAGiB,KAAK,CAAC,CAAC,CAAC;QACZC,EAAE,GAAGnB,CAAC,GAAG,CAAC;QACVoB,EAAE,GAAGnB,CAAC,GAAG,CAAC;QACVoB,EAAE,GAAGC,KAAK,CAACtD,MAAM,CAACoD,EAAE,GAAG1D,EAAE,GAAGyD,EAAE,CAAC,CAAC;MACpC,IAAInB,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAGtC,EAAE,IAAIyD,EAAE,KAAKnB,CAAC,EAAE;QAC/BkB,KAAK,CAAC,CAAC,CAAC,GAAGK,OAAO,CAACvB,CAAC,EAAEsB,KAAK,CAACtD,MAAM,CAACoD,EAAE,GAAG1D,EAAE,GAAGyD,EAAE,GAAG,CAAC,CAAC,CAAC,EAAEE,EAAE,EAAE1C,KAAK,CAAC;MACnE;MACA,IAAIsB,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAGtC,EAAE,IAAIyD,EAAE,KAAKnB,CAAC,EAAE;QAC/BiB,KAAK,CAAC,CAAC,CAAC,GAAGK,OAAO,CAACtB,CAAC,EAAEqB,KAAK,CAACtD,MAAM,CAAC,CAACoD,EAAE,GAAG,CAAC,IAAI1D,EAAE,GAAGyD,EAAE,CAAC,CAAC,EAAEE,EAAE,EAAE1C,KAAK,CAAC;MACrE;IACF,CAAC,CAAC;EACJ;EAEAZ,QAAQ,CAACa,OAAO,GAAGA,OAAO;EAE1Bb,QAAQ,CAACyD,IAAI,GAAG,UAASC,CAAC,EAAE;IAC1B,IAAI,CAACC,SAAS,CAACpD,MAAM,EAAE,OAAO,CAACZ,EAAE,EAAEC,EAAE,CAAC;IACtC,IAAIgE,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC;MAAEK,EAAE,GAAGF,IAAI,CAACC,KAAK,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC;IAChD,IAAI,EAAEE,EAAE,IAAI,CAAC,IAAIG,EAAE,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI9C,KAAK,CAAC,cAAc,CAAC;IAC1D,OAAOtB,EAAE,GAAGiE,EAAE,EAAEhE,EAAE,GAAGmE,EAAE,EAAE/D,QAAQ;EACnC,CAAC;EAEDA,QAAQ,CAACgE,UAAU,GAAG,UAASN,CAAC,EAAE;IAChC,OAAOC,SAAS,CAACpD,MAAM,IAAIV,SAAS,GAAG,OAAO6D,CAAC,KAAK,UAAU,GAAGA,CAAC,GAAGvD,KAAK,CAACC,OAAO,CAACsD,CAAC,CAAC,GAAGnE,QAAQ,CAACH,KAAK,CAAC6E,IAAI,CAACP,CAAC,CAAC,CAAC,GAAGnE,QAAQ,CAACmE,CAAC,CAAC,EAAE1D,QAAQ,IAAIH,SAAS;EACtJ,CAAC;EAEDG,QAAQ,CAACF,MAAM,GAAG,UAAS4D,CAAC,EAAE;IAC5B,OAAOC,SAAS,CAACpD,MAAM,IAAIT,MAAM,GAAG4D,CAAC,GAAG3D,YAAY,GAAGN,IAAI,EAAEO,QAAQ,IAAIF,MAAM,KAAKC,YAAY;EAClG,CAAC;EAED,OAAOC,QAAQ;AACjB;;AAEA;AACA,SAASM,MAAMA,CAAC2B,CAAC,EAAE;EACjB,OAAOiC,QAAQ,CAACjC,CAAC,CAAC,GAAGA,CAAC,GAAGlB,GAAG;AAC9B;;AAEA;AACA;AACA,SAASwB,KAAKA,CAACN,CAAC,EAAErB,KAAK,EAAE;EACvB,OAAOqB,CAAC,IAAI,IAAI,GAAG,KAAK,GAAG,CAACA,CAAC,IAAIrB,KAAK;AACxC;;AAEA;AACA,SAAS2C,KAAKA,CAACzC,CAAC,EAAE;EAChB,OAAOA,CAAC,IAAI,IAAI,IAAIE,KAAK,CAACF,CAAC,GAAG,CAACA,CAAC,CAAC,GAAG,CAACqD,QAAQ,GAAGrD,CAAC;AACnD;AAEA,SAAS0C,OAAOA,CAACvB,CAAC,EAAEmC,EAAE,EAAEd,EAAE,EAAE1C,KAAK,EAAE;EACjC,MAAMyD,CAAC,GAAGzD,KAAK,GAAGwD,EAAE;EACpB,MAAME,CAAC,GAAGhB,EAAE,GAAGc,EAAE;EACjB,MAAMG,CAAC,GAAGL,QAAQ,CAACG,CAAC,CAAC,IAAIH,QAAQ,CAACI,CAAC,CAAC,GAAGD,CAAC,GAAGC,CAAC,GAAGT,IAAI,CAACW,IAAI,CAACH,CAAC,CAAC,GAAGR,IAAI,CAACW,IAAI,CAACF,CAAC,CAAC;EAC1E,OAAOtD,KAAK,CAACuD,CAAC,CAAC,GAAGtC,CAAC,GAAGA,CAAC,GAAGsC,CAAC,GAAG,GAAG;AACnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}