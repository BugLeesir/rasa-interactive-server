{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Adder } from \"d3-array\";\nimport { areaStream, areaRingSum } from \"./area.js\";\nimport { cartesian, cartesianCross, cartesianNormalizeInPlace, spherical } from \"./cartesian.js\";\nimport { abs, degrees, epsilon, radians } from \"./math.js\";\nimport stream from \"./stream.js\";\nvar lambda0, phi0, lambda1, phi1,\n  // bounds\n  lambda2,\n  // previous lambda-coordinate\n  lambda00, phi00,\n  // first point\n  p0,\n  // previous 3D point\n  deltaSum, ranges, range;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function () {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function () {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon) phi1 = 90;else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function () {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n      equatorial = [normal[1], -normal[0], 0],\n      inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n      sign = delta > 0 ? 1 : -1,\n      lambdai = inflection[0] * degrees * sign,\n      phii,\n      antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\nexport default function (feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n  ranges = range = null;\n  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];\n}","map":{"version":3,"names":["Adder","areaStream","areaRingSum","cartesian","cartesianCross","cartesianNormalizeInPlace","spherical","abs","degrees","epsilon","radians","stream","lambda0","phi0","lambda1","phi1","lambda2","lambda00","phi00","p0","deltaSum","ranges","range","boundsStream","point","boundsPoint","lineStart","boundsLineStart","lineEnd","boundsLineEnd","polygonStart","boundsRingPoint","boundsRingStart","boundsRingEnd","polygonEnd","sphere","lambda","phi","push","linePoint","p","normal","equatorial","inflection","delta","sign","lambdai","phii","antimeridian","angle","add","rangeCompare","a","b","rangeContains","x","feature","i","n","merged","deltaMax","Infinity","length","sort","NaN"],"sources":["E:/MyCodes/Rasa/rasa_project_for_windows/rasa_project_front/rasa_project_front/node_modules/d3-geo/src/bounds.js"],"sourcesContent":["import {Adder} from \"d3-array\";\nimport {areaStream, areaRingSum} from \"./area.js\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian.js\";\nimport {abs, degrees, epsilon, radians} from \"./math.js\";\nimport stream from \"./stream.js\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum,\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}